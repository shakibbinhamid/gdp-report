\chapter{E2E Test Framework}
\label{chap:e2e-test-framework}

\section{Automated E2E Testing}
\label{sec:automated-e2e-testing}

\subsection{Manual vs Automatic E2E Testing}
\label{sec:manual-vs-automatic-e2e-testing}

\subsection{Technologies Used}
\label{sec:technologies-used}

\section{Test Framework Components}
\label{sec:test-framework-components}

\subsection{Feature Definition as Requirements}
\label{subsec:feautre-definition-as-requirements}

Feature files can be seen as an entry point to cucumber test cases \cite{featurefile1}. Each of the feature file should be written to test a single feature of the application or a particular area of feature \cite{featurefile2}. Since we were writing E2E tests for the payment feature, we created \texttt{buycredits.feature} file for testing this aspect. Consider \textbf{Listing \ref{lst:buycredits-feature-file}}:\\

\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray, fontsize=\small]{cucumber}
@dev @experiment
Feature: Buying Credit feature
  As a user of Synote
  I should be able to successfully buy credits when logged in

  Scenario: Access buy credits page when logged in
    Given I click the "Profile" button on "SideMenu" page
    Given I click the "BuyCredit" button on "Profile" page
    Then I should be on "BuyCredits" page

  Scenario: Buy credit with empty card number
    Given I click the "Profile" button on "SideMenu" page
    Given I click the "BuyCredit" button on "Profile" page
    Given I Correctly type in my details but "" for "number"
    Then Submit button should be disabled
# code omitted
\end{minted}
\captionof{listing}{Section of \texttt{buycredits.feature} file}
\label{lst:buycredits-feature-file}
\end{listing}

The section in \textbf{Listing \ref{lst:buycredits-feature-file}} is written in a language called \texttt{Gherkin}. \texttt{Gherkin} makes use of Business Readable Domain Specific Language (BRDSL) which allows us to write the test cases at a business level without getting into implementation details.

Our client required us to document the requirements/specification for the new payment feature. Most of Synote's team are developers and since the feature file used \texttt{Gherkin}, it was readable on a business level and could act as automation test script \cite{featurefile1}. Hence, we recommended using the feature files themselves as the requirements documentation.\\

Each of the feature file should be defined with \texttt{Feature} keyword which consists of a name  (see \textbf{Listing \ref{lst:buycredits-feature-file}} line  2) and brief description  (see \textbf{Listing \ref{lst:buycredits-feature-file}} line  3-4). Each of the test cases are defined with \texttt{Scenario} keyword followed by a brief description of that test (see \textbf{Listing \ref{lst:buycredits-feature-file}} line  6 and 11). Each scenario should \cite{featurefile3}:
\begin{itemize}
\item Describe event taking place
\item Describe expected result
\end{itemize}

We use \texttt{Steps} to achieved this. Consider the \texttt{Access buy credits page when logged in} scenario in \textbf{Listing \ref{lst:buycredits-feature-file}}. We use keywords such as \texttt{Given} (line 7 and 8), \texttt{Then} (line 9) for writing readable test cases. Consider \textbf{Table \ref{tab:steps-keywords}} which define \texttt{Step} keywords \cite{featurefile1}

\begin{center}
%Column widths dependent on page width/margins
\begin{tabular}{ |p{2cm}|p{7cm}| }

 \hline
 	Keyword &
 	Description\\
 \hline
 	Given & Describes test pre-condition\\
 \hline
 	And & Defines additional test conditions\\
 \hline
 	Then & Defines expectations of test \\
 \hline

\end{tabular}
\captionof{table}{\texttt{Step keywords}}
\label{tab:steps-keywords}
\end{center}

\subsection{Reusable Steps Definition}
\label{subsec:reusable-steps-definition}

Cucumber is not able to execute the scenarios as they are. Instead, we have to write \texttt{step} definitions. Step definitions use regular expression to map the \texttt{Gherkin steps} to actions which will drive system interactions \cite{stepfile1}. Each of the \texttt{steps} written for scenarios in the \texttt{feature} file should have a \texttt{step} definition declared in its corresponding \texttt{step} file.\\ A \texttt{step} file should only contain definitions for \texttt{steps} used in corresponding \texttt{feature} file. Consider \textbf{Listing \ref{lst:buycredits-step-file}}:\\

\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray, fontsize=\small]{js}
@dev @experiment
//code omitted
this.Given(/^I click the "([^"]*)" button on "([^"]*)" page$/,
  function (buttonName, pageName) {
    return this.Support.clickButton(buttonName, pageName);
});

this.Given(/^I should be on "([^"]*)" page$/, function (pageName) {
  return this.Support.waitUntil
      (this.Support.urlChanged(this.Support.getPageUrl(pageName))
    , 2000)();
});
//code omitted
\end{minted}
\captionof{listing}{Section of \texttt{buycredits.steps.js} file}
\label{lst:buycredits-step-file}
\end{listing}

In our case, all the \texttt{steps} written in \texttt{buycredits.feature} file are defined in the \texttt{buycredits.steps.js} file. Each step should have a unique definition else an \texttt{ambiguous match} exception will be thrown. \textbf{Listing \ref{lst:buycredits-step-file}} contains the step definitions for \texttt{Access buy credits page when logged in} scenario in \textbf{Listing \ref{lst:buycredits-feature-file}}. Inside the step definitions, we write javascript code to handle the interaction logic e.g. 1st definition in \textbf{Listing \ref{lst:buycredits-step-file}} (line 3) handles clicking of button provided  \texttt{buttonName and pageName} parameters and 2nd definition (line 7) handles checking we are on a page with certain URL provided  \texttt{pageName} parameter. Nearly all of out step definitions take parameters instead of hard-coding them. This way, we can satisfy the \texttt{DRY} principle by reusing generic step definitions, making both  \texttt{feature} and  \texttt{step} files easily maintainable and readable in the long run.

\subsection{Reusable Support Functions}
\label{subsec:reusable-support-functions}

In order to have generic \texttt{step} definitions (e.g. see \textbf{Listing \ref{lst:buycredits-step-file}} line 3 and 7), we needed to write common generic methods which will drive interactions with the system. We place such functions in the \texttt{support.js} file. As a rule of thumb, we identified generic methods to go in the \texttt{support.js} file by checking if were were repeating any code/logic in the \texttt{bycredits.steps.js} file. Currently, our frame work uses the \texttt{support.js} file for:

\begin{itemize}
\item Clicking
\item Filling inputs
\item Navigating
\item Data retrieval
\end{itemize}

\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray, fontsize=\small]{js}
@dev @experiment
//code omitted
function loadPageOnSupport(pageName) {
  if (!support[pageName]) {
    support[pageName] = require
      ('../pages/' + pageName.toLowerCase() + '.page.js');
  }
}
//code omitted
fillInputOnPage: function (pageName, textBox, text) {
  loadPageOnSupport(pageName);
  if (this[pageName] && this[pageName][textBox + 'Input']) {
    var _textBox = this[pageName][textBox + 'Input'];
    return _textBox.sendKeys(text);
  }
}
//code omitted
\end{minted}
\captionof{listing}{Section of \texttt{support.js} file}
\label{lst:support-file-methods}
\end{listing}

Consider \textbf{Listing \ref{lst:support-file-methods}}. The \texttt{fillInputOnPage} is a common generic method i.e. it can be used to fill any input field on any page, hence its placement in the \texttt{support.js} file. The \texttt{loadPageOnSupport} method helps \texttt{support.js} file to be generic in applying its methods in different contexts by dynamically requiring desired pages objects. Main advantage of \texttt{support.js} is that testers will never have to rewrite any code they have already written, satisfying the \texttt{DRY} principle.

\subsection{Pre and Post Hooks}
\label{subsec:pre-and-post-hooks}

\subsection{Page Objects}
\label{subsec:page-objects}
There are few key interactions which are very common throughout the application e.g. clicking buttons, filling in inputs, navigating to pages etc. It seemed tedious and time consuming to actually write separate methods for these interactions on different pages. We came to the conclusion that the interactions themselves should be generic enough so they can be applied to any page. The pages of application differed in the elements and components they had. Hence, we have definitions of \texttt{Page Object Models} which is composed of elements a page has.

\begin{minipage}{.48\textwidth}
\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray, fontsize=\small]{js}
{ // buyCredits.page.js snippet
Title : "BuyCredits",
Url : browser.deployment.hostUrl + 'buycredit',

billing_nameInput : element
  (by.model('billingName')),

numberInput : element
  (by.model('cardNumber')),

cvcInput : element
  (by.model('cardCVC')),

exp_monthInput : element
  (by.model('expMonth')),

exp_yearInput : element
  (by.model('expYear')),

PaySavedRadioButton : element
  (by.id('pay-saved-radio')),
//code omitted
}
\end{minted}
\captionof{listing}{Section of \texttt{buycredits.page.js} file}
\label{lst:buycredits-page-code}
\end{listing}
\vspace{0.1cm}
\end{minipage}%
\begin{minipage}{.49\textwidth}
  \includegraphics[width=\textwidth]{screenshot-payment-form.png}
  \captionof{figure}{Payment Form}
 	\label{fig:paymentform-screenshot}
\end{minipage}

Here you have the \texttt{buycredits.html} page (\textbf{Figure \ref{fig:paymentform-screenshot}}) and it's corresponding \texttt{buycreditspage.js} \textit{page object file} (\textbf{Listing \ref{lst:buycredits-page-code}}) which is basically a one to one mapping from the html page components. Page object files also house methods to interact with elements (defined in the same \textit{page object model}) which are only applicable to the particular page in question e.g. \texttt{buycreditspage.js} has a method called \texttt{fillDefaultCardDetails} which fills in the payment form fields and is only applicable to \texttt{buycredits.html} page. The main advantages of implementing page objects were reduced code duplication and easy maintainability i.e.  if any of the UI element of the application was changed, we only have to modify them in the page object file instead of fixing them in each \texttt{step} which used that UI element \cite{semaphore}. Another advantage is that it structures the framework, improving readability.

\subsection{Deployment Definition}
\label{subsec:deployment-definition}
One of the requirements of our client was that our framework should be capable of running the E2E test suite against different deployments of Synote application. The main concern we had here was that tests which worked on one deployment may not work on another deployment because each deployments of Synote is uses different parameters. For example host url of \texttt{development} deployment is \texttt{http://localhost:9000/\#/} and for  \texttt{experiment} deployment, it is \texttt{https://experiment.synote.com/\#/}. Same with other parameters such as cards e.g. \texttt{development} should use test card whereas live deployments such as \texttt{experiment} should use live cards. It can be very time consuming to manually enter all this data when you want to test a deployment. To overcome this problem, we created \texttt{deployment.js} file which can be used to easily define different deployments of Synote application.

\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray, fontsize=\small]{js}
//code omitted
deployment_name : { // e.g. experiment
  hostUrl : 'deployment_url', // e.g. https://experiment.synote.com
  apiEndpoint : 'backend_rest_api_url',
  defaultUser: {
    password : 'password',
    role: 'test_user_role'
  },
  defaultCard: {
    // test card for dev, real card for staging etc.
  }
}
//code omitted
\end{minted}
\captionof{listing}{Section of \texttt{deployment.js} file}
\label{lst:deployment-file}
\end{listing}

Consider \textbf{Listing \ref{lst:deployment-file}}. Here you can see that each deployment of Synote is defined by different parameters. This way, you only have to define deployment specific data once for running the tests.

\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray, fontsize=\small]{bash}
	conf.js --params.env dev --cucumberOpts.tgs=@deployment_name
\end{minted}
\captionof{listing}{Running the E2E Tests}
\label{lst:specifying-deployment-test-run}
\end{listing}

When running the E2E tests, we simply need to pass the name of object which represents the deployment we want to test against. For example: consider \textbf{Listing \ref{lst:specifying-deployment-test-run}}, here we pass in \texttt{dev} as a parameter so the framework will execute tests on \texttt{development} deployment with data defined in \texttt{dev} object.  To overcome the issues with some tests only being suitable for certain deployments, we used \texttt{cucumber tags} which can be placed on \texttt{feature} keyword of \texttt{feature} files or on desired \texttt{scenarios}. For example, in \textbf{Listing \ref{lst:buycredits-feature-file}} we place \texttt{dev} and \texttt{experiment} keywords on the \texttt{feature} keyword so all the test \texttt{scenarios} will run for both of these deployments. The desired test suite to be executed has to be specified as a parameter when executing the tests (see \textbf{Listing \ref{lst:specifying-deployment-test-run}}).

 \subsection{Example Test Case}
\label{subsec:example-test-case}

When testing a feature of the application, we initially start with a requirement which will form the description of the \texttt{feature file}. For example, say we want to test the \texttt{payment feature} and our requirement is \texttt{As a user of SynoteI should be able to successfully buy credits when logged in}, we would create a feature life like in \textbf{Listing \ref{lst:example-feature-file}}.

\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray, fontsize=\small]{cucumber}
Feature: Buying Credit feature
  As a user of Synote
  I should be able to successfully buy credits when logged in
\end{minted}
\captionof{listing}{Example feature for payment feature}
\label{lst:example-feature-file}
\end{listing}

In \textbf{Listing \ref{lst:example-feature-file}}, we use the \texttt{feature} keyword to title the feature under test i.e. \texttt{payment feature} and write the requirement under it. The requirement is then broken down into sub-requirements which will together satisfy the main requirement. The sub-requirements are written as \texttt{scenarios}. For example, say our sub-requirement was \texttt{Buy credit with valid card details}, then its corresponding \texttt{scenario} will look like:

\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray, fontsize=\small]{cucumber}
# code omitted
Scenario: Buy credit with valid card details
  Given I click the "Profile" button on "SideMenu" page
  Given I click the "BuyCredit" button on "Profile" page
  Given I Correctly type in my details
  And I click the "SubmitPayment" button on "BuyCredits" page
  Then I should be on "CreditsHistory" page
\end{minted}
\captionof{listing}{Example \texttt{Feature} File}
\label{lst:example-feature-file-scenario}
\end{listing}

In \textbf{Listing \ref{lst:example-feature-file-scenario}}, you can see that we've labelled the \texttt{scenario} with the sub-requirement itself and written \texttt{steps} in \texttt{Gherkin} to test it. If any of the \texttt{steps} take in a parameter, we specify them using quotes.\\

Next thing we need to do is create a \texttt{steps} file where we will write step definitions for the 5 steps in \textbf{Listing \ref{lst:example-feature-file-scenario}}. Consider \textbf{Listing \ref{lst:example-steps-file}}.

\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray, fontsize=\small]{js}
module.exports = function () {
  this.Given(/^I click the "([^"]*)" button on "([^"]*)" page$/,
    function (buttonName, pageName) {
      //return this.Support.clickButton(buttonName, pageName);
  });
  this.Given(/^I Correctly type in my details$/, {timeout: 60*1000},
    function () {
      //return this.BuyCreditsPage.fillDefaultCardDetails();
  });
  this.Given(/^I should be on "([^"]*)" page$/,
    function (pageName) {
      //return this.Support.waitUntil
      //  (this.Support.urlChanged(this.Support.getPageUrl(pageName))
      // , 2000)();
  });
}
\end{minted}
\captionof{listing}{Example \texttt{Steps File}}
\label{lst:example-steps-file}
\end{listing}

Consider \textbf{Listing \ref{lst:example-feature-file}}. Here we define the \texttt{steps} we wrote in \textbf{Listing \ref{lst:example-feature-file-scenario}} using reqular expressions. Now we need to actually write code to interact with the html page in question. Follong our framework's principles, we  need to create a \texttt{page object} file as defined in \textbf{Section \ref{subsec:page-objects}}. The \texttt{scnario} we wrote in \textbf{Listing \ref{lst:example-feature-file-scenario}} will be interacting will the payment form (\textbf{See Figure \ref{fig:paymentform-screenshot}}) and we need to consider all the elements and components of payment form to create a one to one mapping to these elements in the \texttt{page object} file. Consider  \textbf{Listing \ref{lst:example-page-file}}.

\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray, fontsize=\small]{js}
var buyCreditsPage = {
  Title : "BuyCredits",
  Url : browser.deployment.hostUrl + 'buycredit',
  billing_nameInput : element(by.model('billingName')),
  numberInput : element(by.model('cardNumber')),
  cvcInput : element(by.model('cardCVC'))
//code omitted
}
\end{minted}
\captionof{listing}{Example \texttt{Steps File}}
\label{lst:example-page-file}
\end{listing}

In \textbf{Listing \ref{lst:example-page-file}}, you can see that we create a map of ll the elements of the payment form. Now we can write code to carry out intercations on the page. The first step definition of clicking some button on some page is pretty generic and following the conventions of our framework metioned in \textbf{Section \ref{subsec:reusable-support-functions}}, we should implement a generic method to handle this interaction in the support.js file.

\subsection{Reporting}
\label{subsec:reporting}

\subsection{Assessment}
\label{subsec:assessment}
The framework's capabilities where thoroughly tested by Deepak, who wrote most of the test cases. To get an outside perspective, Tom, who had no background knowledge using the frame work, came in and tried to write tests using the \texttt{readme.md} documentation.
