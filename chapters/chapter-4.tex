\chapter{Payment Feature}
\label{chap:payment-feature}

% Nomenclature - JSON?

\section{Sever Side Implementation}
\label{sec:server-side-implementation}

The greatest concern in implementing a payment feature for Synote is remaining PCI DSS compliant. To remove most of the burden and with the approval of our client Yunjia Li, Stripe was chosen as the payment gateway. Stripe also allows custom merchant forms which our client favours over redirection and generated forms.\\

\begin{figure}[!hbt]
  	\centering
 	\includegraphics[width=0.78\textwidth]{synote-architecture.png}
  	\caption{Synote Architecture}
 	\label{fig:synote-architecture}
\end{figure}

\textbf{Figure \ref{fig:synote-architecture}} depicts Synote's existing architecture which uses Node.js (Node) and Sails.js (Sails) web frameworks on the server. Sails includes a powerful Object Relational Mapping (ORM) tool called Waterline to provide a data access layer to the underlying MySQL database.\\

As a custom merchant form is desired for gathering payment information, Stripe must be used to tokenize the payment data before it can be sent to Synote's server. As mentioned in \textbf{Section \ref{subsec:security}}, HTTPS is required for secure transmission of payment data over a network, so the first stage of integration is to use an HTTPS/SSL certificate to enable HTTPS communication. The resulting architecture is shown in \textbf{Figure \ref{fig:stripe-integration}}.\\

\begin{figure}[!hbt]
  	\centering
 	\includegraphics[width=0.7\textwidth]{stripe-integration.png}
  	\caption{Integrating Stripe}
 	\label{fig:stripe-integration}
\end{figure}

The first iteration of the payment feature requires simple functionality: A customer must be able to enter payment information to buy \texttt{X} amount of credits which will be stored against their Synote account, along with a record of the transaction. \textbf{Figure \ref{fig:simple-sequence}} shows the full sequence of events necessary to achieve this behavior, however, server side implementation concerns only what happens as a result of the \texttt{POST} action to Synote's server.\\

\begin{figure}[!hbt]
  	\centering
 	\includegraphics[width=\textwidth]{simple-sequence.png}
  	\caption{Sequence Diagram Of Simple Payment}
 	\label{fig:simple-sequence}
\end{figure}

Step one is to create the endpoint to which a Stripe token and any additional required information can be posted. Sails has an API called Blueprint which creates RESTful routes when an endp oint is created with a \texttt{model} and \texttt{controller}. Further routes can be added to the endpoint route through the concept of action routes, thus a \texttt{controller} file named \texttt{CreditHistoryController.js} containing an action route of \texttt{topup} exposes the route: \texttt{/credithistory/topup}.\\

Making charges against a token requires Stripe's API \cite{stripe-api} which can be added using the \texttt{require} keyword and must include a secret key provided by Stripe. Stripe's API lists examples of functions in Node, but in the form of callbacks. As covered in \textbf{Section \ref{sec:synote}}, the convention is to use promises in favour of callbacks which altogether results in code similar to \textbf{Listing \ref{lst:stripe-charge}}.\\

\hspace{0.1\textwidth}
\begin{minipage}{.76\textwidth}

\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray]{js}
return stripe.charges.create({
        amount: cost,
        currency: "gbp",
        source: token.id
});
\end{minted}
\captionof{listing}{Stripe Charge Promisified Example}
\label{lst:stripe-charge}
\end{listing}
\end{minipage}
\hspace{0.1\textwidth}
\vspace{0.3cm}

Information required to make a charge includes a single use token, charge amount and currency. The token and charge amount are provided in the \texttt{POST} from a client as a JSON object in the request (\texttt{req}) body. It is convention that a \texttt{req} is only processed within a \texttt{policy} and \texttt{controller}. Sails uses policies for authorization and access control such that each \texttt{action route} for each \texttt{controller} can be assigned one or more policies. As Synote uses Auth0 \cite{auth0} a policy called \texttt{hasJsonWebToken} exists to add a user's profile to a \texttt{req} which, aside from authorization, has the added benefit of providing a user's ID that can be used to determine which user is making a purchase.\\

\begin{figure}[!hbt]
  	\centering
 	\includegraphics[width=\textwidth]{db-credit.png}
  	\caption{Credit \& Credit History Database Tables}
 	\label{fig:db-credit}
\end{figure}

The remaining task is recording the transaction and assigning purchased credits to a user. The setup for this task requires alteration to the existing database (DB), a Sails \texttt{model} and Waterline methods to interact with the DB. \textbf{Figure \ref{fig:db-credit}} shows the schema of the credit and credit history tables with their relations to the existing user table. Adding these tables to an existing database requires use of an SQL migration file as shown in \textbf{Listing \ref{lst:migration-file}}.\\

\hspace{0.1\textwidth}
\begin{minipage}{.72\textwidth}
\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray, fontsize=\small]{sql}
DROP TABLE IF EXISTS `testing`;
CREATE TABLE `testing` (
  `id` VARCHAR(255) NOT NULL,
  `email` VARCHAR(255) NOT NULL,
  `role` VARCHAR(255) NOT NULL,
  `free` BOOLEAN DEFAULT TRUE,
  `createdAt` datetime DEFAULT NULL,
  `updatedAt` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

\end{minted}
\captionof{listing}{Section Of Migration File: v0.9.0-v0.10.0.sql}
\label{lst:migration-file}
\end{listing}
\end{minipage}
\hspace{0.1\textwidth}
\vspace{0.3cm}

A section of the \texttt{model} file required for Waterline ORM to interact with the database is shown in \textbf{Listing \ref{lst:credit-history-model}}. Each attribute of the \texttt{model} is a one-to-one mapping with a field in the corresponding table, in this case \texttt{stripeChargeResponse} is shown with a type of \texttt{text} which can clearly be seen in the \texttt{credithistory} table of \textbf{Figure \ref{fig:db-credit}}. This field exists to store a record of the charge response from Stripe and contains redacted PCI DSS compliant information such as the last four digits of the charged card. Also of note in \textbf{Listing \ref{lst:credit-history-model}} are two examples of Waterline functions: \texttt{findOne} and \texttt{update} which in this instance are part of a hook to update the quantity of credits for a user after a purchase. These functions are a subset of the available functions to Create, Read, Update and Destroy (CRUD) DB records.

\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray, fontsize=\small]{js}
module.exports = {
  attributes: {
    //Code omitted
    stripeChargeResponse: {
      type: "text",
      isTopUp: true
    },
    //Code omitted
  },

  afterCreate:function(history,cb){
    Credit.findOne({id:history.credit})
      .then(function(oldCredit){
        var newAmount = oldCredit.amount+history.amount;
        return Credit.update({id:history.credit},{amount:newAmount});
      }).then(function(newCredit){
        cb();
      }).catch(function(err){
        cb(err);
      });
  }
};

\end{minted}
\captionof{listing}{CreditHistory.js model file}
\label{lst:credit-history-model}
\end{listing}

The second iteration of the payment feature requires extended functionality: A customer must be able to save payment information for faster future purchases. Stripe provides a method of saving payment data which encapsulates sources such as payment cards in a \textit{customer} object. The ID of a customer object can be used to charge a user's default payment source, or the combination of customer object id and source-data ID can be used to charge a specific card owned by a customer. Building on the first iteration and following the process above, server side implementation for saving cards and paying with saved cards involves:

\begin{enumerate}
	\item Adding action routes in the \texttt{CreditHistoryController.js} file to retrieve/delete cards
    \item Providing additional parameters in the \texttt{req} body JSON to indicate the Stripe token should be used to save the payment data
    \item Adding policies to secure the new routes
    \item Adding Stripe functions to save payment data in a Stripe customer object
    \item Updating the database schema using a migration file to store a Stripe customer object against a user
    \item Updating the relevant \texttt{model} to include the Stripe customer field
    \item Adding Waterline functions to CRUD Stripe customer records in the DB
\end{enumerate}

All of the Stripe and Waterline methods can exist in \texttt{CreditHistoryController.js} file, but this constitutes poor cohesion and it is convention to keep reusable functions in a \texttt{service} file to prevent repetition. Consequently all reusable Stripe functions are placed in \texttt{StripeService.js} and all reusable Waterline functions are placed in \texttt{ChargeService.js} for maximal cohesion. The resulting solution architecture is shown in \textbf{Figure \ref{fig:synote-stripe}}.\\

\begin{figure}[!hbt]
  	\centering
 	\includegraphics[width=\textwidth]{synote-stripe-overview.png}
  	\caption{Overview Of Synote-Stripe Architecture}
 	\label{fig:synote-stripe}
\end{figure}

\section{Server Side Testing}
\label{sec:server-side-testing}

Testing is crucial in order to provide a robust and reliable feature. The existing testing strategy in Synote's server code uses Mocha \cite{mocha} test running framework paired with Chai \cite{chai} assertion library. Unit, Integration and server side end-to-end (E2E) tests have been written for the payment feature. Through use of Istanbul \cite{istanbul} code coverage tool, we can show high coverage in policies, services and the controller as shown in \textbf{Figure \ref{fig:coverage}}. To thoroughly test our implementation we have written tests for presence, edge-cases and branch coverage. A collection of tests from \texttt{StripeService.test.js} are shown in \textbf{Listing \ref{lst:stripe-test-cases}}.\\

\begin{figure}[!hbt]
  	\centering
 	\includegraphics[width=0.9\textwidth]{coverage-all.png}
  	\caption{Istanbul Coverage Report Section}
 	\label{fig:coverage}
\end{figure}

As we were using some of the required technologies for the first time, we had to follow a cycle of prototype-test-refactor meaning we were unable to perform test driven development. Writing tests as part of the development process helped us to spot errors early and know when to change approaches or simply refactor. Where appropriate, tests were actually written by another team member in parallel with development and our client reviewed our code each week ensuring all code is tested and reviewed.\\

\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray, fontsize=\small]{js}
it('Should throw error "Invalid positive integer" when a negative cost is used', function (done) {...});

it('Should throw error "Amount must be at least 30 pence" when a "too low" cost is used', function (done) {...});

it('Should throw error "Invalid integer: text" when "text" cost is used', function (done) {...});

it('Should throw error "No such customer: badValue" when "badValue" customer is provided', function (done) {...});

it('Should throw error "chargeCard: Missing properties in provided JSON" when no customer is provided', function (done) {...});

\end{minted}
\captionof{listing}{Section Of StripeService.test.js}
\label{lst:stripe-test-cases}
\end{listing}

All test cases attempt to follow the SILO and DRY (Don't Repeat Yourself) principles to ensure each case is independent. While SILO has been completely achieved, DRY has not as the existing testing strategy for policies and controllers has forced code repetition. At present \texttt{policy} and \texttt{controller} files are being tested through endpoint calls which is not considered best practice and results in some code branches not being testable. The desired methodology for testing \texttt{policy} files is to do so in isolation using mocking for \texttt{req} objects and spies for function calls. We have included an example of this in \texttt{canListCreditHistory.text.js} in Synote's repository. Best practice for testing \texttt{controllers} and \texttt{services} is to use dependency injection to remove interaction with a real database and \texttt{http} context. This is far beyond the scope of our project but is recommended as future improvement for Synote.\\

\section{Client Side Implementation}
\label{sec:client-side-implementation}

\subsection{Wireframes}
\label{subsec:wireframes}

First step in design was to mock up some wireframes and get them approved by our Client. Consider the final wireframe iterations below:\\

\begin{figure}[!hbt]
  	\centering
 	\includegraphics[width=0.9\textwidth]{profile-page-payment-feature.png}
  	\caption{Profile Page Payment and Credits Section Wireframe}
 	\label{fig:profile-wireframe}
\end{figure}

\begin{figure}[!hbt]
  	\centering
 	\includegraphics[width=0.9\textwidth]{credits-history-wireframe.png}
  	\caption{Credits History Wireframe}
 	\label{fig:credits-history-wireframe}
\end{figure}

\begin{figure}[!hbt]
  	\centering
 	\includegraphics[width=0.9\textwidth]{payment-form-wireframe.png}
  	\caption{Payment Form Wireframe}
 	\label{fig:payment-form-wireframe}
\end{figure}

\begin{figure}[!hbt]
  	\centering
 	\includegraphics[width=0.9\textwidth]{saved-card-wireframe.png}
  	\caption{Saved Card Payment Form Wireframe}
 	\label{fig:saved-card-wireframe}
\end{figure}

\subsection{Payment System Infrastructure (Frontend)}
\label{subsec:payment-system-infrastructure}

\begin{figure}[!hbt]
  	\centering
 	\includegraphics[width=0.7\textwidth]{frontend-infrastructure.png}
  	\caption{Frontend Infrastructure}
 	\label{fig:frontend-infrastructure-diagram}
\end{figure}

Client side should handle these properties of the payment feature:

\begin{itemize}
\item Displaying credits history of logged in user
\item Redemption of credits via new card
\item Redemption of credits via saved card
\item Deletion of saved cards
\item Validation messages
\end{itemize}

“Credits History” and “Buy Credits” are very different components of the payment feature, so we created 2 separate controllers i.e. “buycredit” controller and “creditshistory” controller to handle their logic independently.\\  

\subsubsection{Buy Credits Feature}
\label{subsubsec:buy-credits-feature}

As mentioned in \textbf{Figure \ref{fig:simple-sequence}} in \textbf{Section \ref{sub:server-side-implementation}}, it’s the clientside’s responsibility to tokenise payment data and handle the response from Stripe. The “buycredit” controller handles all the payment related business logic with the help of “paymentcervice” service class (see \textbf{Figure \ref{fig:frontend-infrastructure-diagram}}). This class provides the “buycredit” controller with:

\begin{itemize}
\item Stripe tokenisation and response handler methods
\item Payment form input validation methods
\item Charge card method (server request) 
\item Delete card method (server request)
\end{itemize}

Initially, all of this logic was handled by the “buycredits” controller itself and this lead to lot of code repetition. Doing simple things like changing the POST request URL for charging a card a hassle since we had to make these changes at multiple locations. We refactored all the reusable functions into “paymentservice” making amendments a hassle free job. \\

\textbf{Making a Payment}\\
To use Stripe.js on client side, we first had to include its library as a script in the head of “index.html” page. Consider \textbf{Listing \ref{lst:index-head-html}}:\\

\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray, fontsize=\small]{bash}
<head>
 <meta charset="utf-8">
 <title>Synote</title>
 //code omitted
 <script type="text/javascript" src="https://js.stripe.com/v2/"></script>
 //code omitted
</head>
\end{minted}
\captionof{listing}{Section of index.html file}
\label{lst:index-head-html}
\end{listing}

We also had to include our actual publishable API key as a script which will be used to identify Synote to Stripe when sending requests. Consider \textbf{Listing \ref{lst:buycredit-html-stripe-key}}:\\

\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray, fontsize=\small]{bash}
//code omitted    
<form name="theForm" class="form-group" id="payment-form" novalidate>
 <script type="text/javascript">
 Stripe.setPublishableKey('pk_test_4FAeir9iMLjc76qM8Tn4Cn1p');
 </script>
//code omitted   
\end{minted}
\captionof{listing}{Section of buycredit.html file}
\label{lst:buycredit-html-stripe-key}
\end{listing}
 
Payment can be of 2 forms; via a saved card or via a new card.\\
 
\textbf{Via New Card}\\
When we were implementing the payment form, the main thing we had to ensure from client side was secure transmission of card details i.e. they shouldn't be intercepted and manipulated by an outsider. To achieve this level of security, we tokenise the critical payment fields via Stipe’s API and post this to Synote’s server along with other details such as amount of credits and price to pay. This way, we can assure that original values won't be sent to the server.\\

\textbf{Tokenisation of Payment Details}\\ 
“paymentservice” is responsible for converting the user input payment details into a single use representative token.  Consider \textbf{Listing \ref{lst:create-token-payment-service-method}}:\\
 
\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray, fontsize=\small]{bash}
//code omitted    
createStripeToken: function (tokenHelperObject) {
 var deferred = \$q.defer(); //serve as the object which will create and manage the promise
 Stripe.card.createToken(tokenHelperObject, function (status, response) {
 if (response.error) {
  //if createToken method fails, reject the promise
  deferred.reject(response.error);
 } else {
  //if the createToken method succeeds, resolve the promise
  deferred.resolve(response);
 }});
  return deferred.promise;//return the promise
 },
//code omitted   
\end{minted}
\captionof{listing}{Section of paymentservice.js file}
\label{lst:create-token-payment-service-method}
\end{listing}
 
The method provided by Stripe’s API is “Stripe.Card.createToken” (line 4). This is in callback style and Synote’s conventions (see \textbf{Section \ref{subsec:conventions}}) favours promises over callbacks. Hence, we created “createStripeToken” method which uses Angular’s “\$q” constructor service to to turn callbacks into promises [1] \& [2]. The token helper object consists of input payment details i.e. billing name, number, cvc, expiry month and year.\\ 
 
If the response from Stripe was successful, “buyCredit” controller will then move onto processing the payment via “paymentService.” Consider \textbf{Listing \ref{lst:charge-card-service-method}}:\\

\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray, fontsize=\small]{bash}
//code omitted    
 chargeCard: function (parameters) {
  return \$http({
   url: ENV.apiEndpoint + '/CreditHistory/topup',
   method: 'POST',
   data: parameters
  });
 },
//code omitted   
\end{minted}
\captionof{listing}{Section of paymentservice.js file}
\label{lst:charge-card-service-method}
\end{listing} 
 
Here we simply make a post request to Synote’s server at “topup” endpoint along with the single use representative token, credits, charge amount, save boolean as parameters. Save boolean flag is set true if user checks the save card option. It tells the server to save the card currently used for payment.\\ 

\textbf{Via Saved Card}\\
The logic behind is similar to using a new card apart from the fact that we no longer need to tokenize the payment details. When user is routed to the “buycredit” URI, we send an HTTP Get request to Synote’s server to retrieve saved cards for logged in user (see \textbf{Figure \ref{fig:frontend-infrastructure-diagram}}). Consider \textbf{Listing \ref{lst:get-cards-req}}:\\

\begin{listing}[H]
\begin{minted}[xleftmargin=\parindent, linenos, breaklines, breakanywhere, bgcolor=lightgray, fontsize=\small]{bash}
//code omitted    
 cards: ['\$http', 'authenticationService', function (\$http, authenticationService) {
  var usrId = authenticationService.getUserInfo().user_id;
  return \$http({
   url: ENV.apiEndpoint + '/creditHistory/cards',
   method: "GET"
 });
 }]
//code omitted   
\end{minted}
\captionof{listing}{Section of app.js file}
\label{lst:get-cards-req}
\end{listing} 











